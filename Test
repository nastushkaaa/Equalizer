import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import zpk2tf, freqz
from scipy.io import wavfile

class Equalizer:
    def __init__(self, fs):
        self.fs = fs
        self.audio = None

    def afc(self, f, num_freq, coef):
        alpha = 7e-7
        x = np.zeros(len(f))
        for i in range(len(num_freq)):
            x += coef[i] * np.exp(-alpha * (f - self.fs * num_freq[i] / n)**2)
        return x

    def apply_equalizer(self, audio, coef):
        spectrum = np.fft.rfft(audio)
        f = np.linspace(0, self.fs/2, len(spectrum), endpoint=True)
        filter = self.afc(f, num_freq, coef)
        spectrum_filtered = spectrum * filter
        audio_filtered = np.fft.irfft(spectrum_filtered).real
        return audio_filtered

    def save_audio(self, audio, filename='C:\\Users\\Админ\\Downloads\\filtered_audio.wav'):
        scale_factor = np.iinfo(np.int16).max
        wavfile.write(filename, self.fs, (audio * scale_factor).astype(np.int16))

    def play_audio(self, audio):
        self.save_audio(audio)
        rate, audio_output = wavfile.read("C:\\Users\\Админ\\Downloads\\filtered_audio.wav")
        self.audio = audio_output
        return audio_output

# Read the original WAV file
filename = 'C:\\Users\\Админ\\Downloads\\Белый шум, White Noise Sound (Wave PCM).wav'
rate, audio_original = wavfile.read(filename)

# Create an Equalizer object
eq = Equalizer(rate)

# Apply the equalizer to the audio data
audio_filtered = eq.apply_equalizer(audio_original, coef)

# Save the filtered audio to a new WAV file
eq.save_audio(audio_filtered, 'C:\\Users\\Админ\\Downloads\\filtered_audio.wav')

# Plot the waveform of the original and filtered audio
plt.subplot(3, 1, 1)
plt.plot(audio_original)
plt.xlabel('Time (samples)')
plt.ylabel('Amplitude')
plt.title('Waveform of the original audio')

plt.subplot(3, 1, 2)
plt.plot(audio_filtered)
plt.xlabel('Time (samples)')
plt.ylabel('Amplitude')
plt.title('Waveform of the filtered audio')

# Plot the impulse response of the equalizer
circ = np.exp(1j * np.linspace(0, 2*np.pi, 360, endpoint=True))

n = 8

psi = np.linspace(0, np.pi, n + 1, endpoint=False)
p0 = 0.75 * np.exp(1j * psi)
p = np.hstack((p0, np.conj(p0[-1:0:-1])))

z = 1 / np.conj(p)

gain = 1 + 0.08 * np.random.randn(n)
z1 = np.copy(z)
z1[1:n+1] = gain * z1[1:n+1]
z1[n+1:] = gain[-1::-1] * z1[n+1:]

k = np.prod(np.abs(p))
k1 = np.prod(np.abs(1/z1))
a, b = zpk2tf(z, p, k)
a1, b1 = zpk2tf(z1, p, k1)

plt.subplot(3, 1, 3)
plt.plot(np.arange(len(a)), a, '-r', label='Импульсная характеристика, н.у.')
plt.plot(np.arange(len(a1)), a1, '-b', label='Импульсная характеристика, с усилением')
plt.xlabel('Отсчет')
plt.ylabel('Амплитуда')
plt.legend()

# Plot the frequency response of the equalizer
f, h = freqz(b, a, 1024)
f1, h1 = freqz(b1, a1, 1024)

plt.figure()
plt.subplot(2, 1, 1)
plt.plot(f / np.pi, 10*np.log10(np.abs(h)), '-r', label='АЧХ, н.у.')
plt.plot(f / np.pi, 10*np.log10(np.abs(h1)), '-b', label='АЧХ, с усилением')
plt.xlabel('Частота / π')
plt.ylabel('Амплитуда, дБ')
plt.legend()

# plt.subplot(2, 1, 2)
# plt.plot(f / np.pi, np.angle(h), '-r', label='ФЧХ, н.у.')
# plt.plot(f / np.pi, np.angle(h1), '-b', label='ФЧХ, с усилением')
# plt.xlabel('Частота / π')
# plt.ylabel('Фаза, рад')
# plt.legend()

plt.tight_layout()
plt.show()
